\documentclass{article}
\usepackage[utf8]{inputenc}       
\usepackage[T1]{fontenc}          
\usepackage[polish]{babel}         
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\geometry{a4paper, margin=1in}

% Definicje kolorów dla listingu
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}

% Ustawienia listingu
\lstset{
    basicstyle=\ttfamily\small,
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    literate={ą}{{\k{a}}}1
             {ć}{{\'c}}1
             {ę}{{\k{e}}}1
             {ł}{{\l}}1
             {ń}{{\'n}}1
             {ó}{{\'o}}1
             {ś}{{\'s}}1
             {ź}{{\'z}}1
             {ż}{{\.z}}1
             {Ą}{{\k{A}}}1
             {Ć}{{\'C}}1
             {Ę}{{\k{E}}}1
             {Ł}{{\L}}1
             {Ń}{{\'N}}1
             {Ó}{{\'O}}1
             {Ś}{{\'S}}1
             {Ź}{{\'Z}}1
             {Ż}{{\.Z}}1
}

\title{Algorytmy numeryczne 1.1 - Interpolacja Newtona}
\author{Przemysław Sawoniuk, Jeremiasz Olech}
\date{26.11.2025}

\begin{document}

\maketitle

\section{Podstawy teoretyczne}
Dla $n+1$ punktów $(x_0, y_0), (x_1, y_1), \dots, (x_n, y_n)$, gdzie $x_i$ są różne, wielomian interpolacyjny w \textbf{postaci Newtona} ma postać:
\[
P_n(x) = a_0 + a_1(x - x_0) + a_2(x - x_0)(x - x_1) + \dots + a_n(x - x_0)\cdots(x - x_{n-1}),
\]
gdzie:
\begin{itemize}
\item $a_k = f[x_0, x_1, \dots, x_k]$ to \textbf{ilorazy różnicowe} rzędu $k$,
    \item Ilorazy obliczane są rekurencyjnie:
    \[
    f[x_i, \dots, x_j] = \frac{f[x_{i+1}, \dots, x_j] - f[x_i, \dots, x_{j-1}]}{x_j - x_i}.
    \]
\end{itemize}

\section{Kod w Pythonie}
\subsection{Pełny kod}
\begin{lstlisting}[language=Python, caption=Interpolacja Newtona z obsługą błędów]
import sys
from validation import validate_and_parse

def main():
    print(
        "Podaj dane w następującym formacie:\n"
        "n\n"
        "x0 x1 ... xn\n"
        "y0 y1 ... yn\n"
        "t1 t2 ... (opcjonalnie kolejne linie z t)\n\n"
        "Po zakończeniu wpisywania danych naciśnij:\n"
        " - Ctrl+D  (Linux/Mac)\n"
        " - Ctrl+Z+Enter  (Windows)\n"
    )
    data = sys.stdin.read().splitlines()
    try:
        n, x, y, t_values = validate_and_parse(data)
    except ValueError as e:
        print("Błąd:", e)
        return
    
    m = n + 1
    coeffs = y.copy()
    
    for i in range(1, m):
        for j in range(m - 1, i - 1, -1):
            coeffs[j] = (coeffs[j] - coeffs[j - 1]) / (x[j] - x[j - i])
    
    results = []
    for t in t_values:
        result = coeffs[-1]
        for i in range(m - 2, -1, -1):
            result = coeffs[i] + (t - x[i]) * result
        results.append(result)
    
    for res in results:
        print(res)

if __name__ == "__main__":
    main()
\end{lstlisting}

\subsection{Moduł walidacji}
\begin{lstlisting}[language=Python, caption=validation.py]
def validate_and_parse(data):
    if not data:
        raise ValueError("Brak danych wejściowych.")

    # n
    try:
        n = int(data[0].strip())
    except ValueError:
        raise ValueError("Pierwsza linia musi zawierać liczbę całkowitą n.")

    if n < 1:
        raise ValueError("n musi być >= 1.")

    if len(data) < 3:
        raise ValueError("Zbyt mało linii danych - oczekiwane: n, x, y.")

    # x
    try:
        x = list(map(float, data[1].split()))
    except ValueError:
        raise ValueError("Linia 2 musi zawierać wartości liczbowe x.")

    if len(x) != n + 1:
        raise ValueError(f"Dla n={n} należy podać dokładnie {n+1} wartości x (podano {len(x)}).")

    if len(set(x)) != len(x):
        raise ValueError("Wartości x muszą być unikalne.")

    # y
    try:
        y = list(map(float, data[2].split()))
    except ValueError:
        raise ValueError("Linia 3 musi zawierać wartości liczbowe y.")

    if len(y) != n + 1:
        raise ValueError(f"Dla n={n} należy podać dokładnie {n+1} wartości y (podano {len(y)}).")

    # t
    t_values = []
    for line in data[3:]:
        try:
            t_values.extend(map(float, line.split()))
        except ValueError:
            raise ValueError("W liniach z t muszą znajdować się liczby.")

    if not t_values:
        raise ValueError("Brak punktów t do obliczenia interpolacji.")

    return n, x, y, t_values
\end{lstlisting}

\section{Obsługa błędów}
\subsection{Kluczowe mechanizmy walidacji}
\begin{enumerate}
    \item \textbf{Sprawdzenie podstawowych warunków:}
    \item Dane wejściowe nie mogą być puste
        \item Liczba $n$ musi być całkowita i $\geq 1$
        \item Muszą być podane wszystkie linie: $n$, $x$, $y$
    
    \item \textbf{Walidacja węzłów $x$:}
    \item Wartości muszą być liczbowe
        \item Liczba węzłów musi wynosić dokładnie $n+1$
        \item Węzły muszą być unikalne (brak powtórzeń)
    
    \item \textbf{Walidacja wartości $y$:}
    \item Wartości muszą być liczbowe
        \item Liczba wartości musi wynosić dokładnie $n+1$
    
    \item \textbf{Walidacja punktów $t$:}
    \item Wartości muszą być liczbowe
        \item Musi istnieć co najmniej jeden punkt $t$
\end{enumerate}

\subsection{Przykłady błędów i komunikaty}
\begin{lstlisting}[frame=single, backgroundcolor=\color{gray!10}, basicstyle=\small\ttfamily]
Błąd: Brak danych wejściowych.
Błąd: Pierwsza linia musi zawierać liczbę całkowitą n.
Błąd: n musi być >= 1.
Błąd: Zbyt mało linii danych - oczekiwane: n, x, y.
Błąd: Linia 2 musi zawierać wartości liczbowe x.
Błąd: Dla n=2 należy podać dokładnie 3 wartości x (podano 2).
Błąd: Wartości x muszą być unikalne.
Błąd: Linia 3 musi zawierać wartości liczbowe y.
Błąd: Dla n=2 należy podać dokładnie 3 wartości y (podano 4).
Błąd: W liniach z t muszą znajdować się liczby.
Błąd: Brak punktów t do obliczenia interpolacji.
\end{lstlisting}

\section{Przykład działania}
\subsection{Dane wejściowe (poprawne)}
\begin{lstlisting}
2
0.0 1.0 2.0
1.0 2.0 5.0
0.5 1.5
\end{lstlisting}

\subsection{Wynik}
\begin{lstlisting}
1.25
3.25
\end{lstlisting}

\subsection{Błędne dane wejściowe i komunikaty}
\begin{lstlisting}[frame=single, backgroundcolor=\color{gray!10}, basicstyle=\small\ttfamily]
2
0.0 1.0 0.0
1.0 2.0 5.0
0.5 1.5

Błąd: Wartości x muszą być unikalne.
\end{lstlisting}

\begin{lstlisting}[frame=single, backgroundcolor=\color{gray!10}, basicstyle=\small\ttfamily]
2
0.0 1.0 2.0
1.0 2.0
0.5 1.5

Błąd: Dla n=2 należy podać dokładnie 3 wartości y (podano 2).
\end{lstlisting}

\begin{lstlisting}[frame=single, backgroundcolor=\color{gray!10}, basicstyle=\small\ttfamily]
2
0.0 1.0 2.0
1.0 2.0 5.0

Błąd: Brak punktów t do obliczenia interpolacji.
\end{lstlisting}

\section{Podsumowanie}
\begin{itemize}
\item Program \textbf{sprawdza poprawność danych} przed przystąpieniem do obliczeń
    \item \textbf{Precyzyjne komunikaty błędów} wskazują, co jest nie tak
    \item \textbf{Oddzielny moduł walidacji} zapewnia czytelność kodu
    \item Program \textbf{nie przerywa działania} w przypadku błędów — wyświetla komunikat i kończy pracę
\end{itemize}

\end{document}
